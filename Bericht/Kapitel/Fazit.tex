\chapter{Fazit und Ausblick}
Im Zuge dieser Arbeit wurde eine Sprachsteuerung für eine Getränkemischmaschine implementiert, mit deren Hilfe der Benutzer Getränke aus den fünf verfügbaren Behältern mischen kann, indem er die Behälter mit der jeweils gewünschten Prozentangabe nennt. Dafür wurde ein Sprachmodell trainiert, welches anhand eines Textes (Spracheingabe des Benutzers) die Prozentangaben für die jeweiligen Behälter extrahiert und die Art der Eingabe klassifiziert. Der Text kann in eine der drei Klassen eingeordnet werden: Bestellung, Begrüßung, Verabschiedung und keine Eingabe. Je nach Klasse werden bestimmte Antworten ausgewählt, die über Lautsprecher an den Benutzer zurückgegeben werden, damit der Eindruck eines Dialogs zwischen Benutzer und Mischmaschine entsteht. Der Code für die Sprachsteuerung wurde in Python implementiert und wird auf einem Raspberry Pi ausgeführt, der an die bestehende Hardware in der Mischmaschine angeknüpft werden musste.
\section{Erfüllung der Anforderungen}
Am Anfang des Projekts wurden verschiedene Anforderungen an das zu entwickelnde System definiert, die nun einer Überprüfung unterzogen werden sollen.\\\\
Um die Anforderung an die Antwortzeit zu testen wurde die Python-Methode \textit{time()} aus der \textit{time}-Bibliothek verwendet, welche die aktuelle Systemzeit zurückgibt. Dafür wurde in Zeile \ref{code:start_time} des Hauptprogramms aus Anhang \ref{Anhang_B} die Startzeit und in Zeile \ref{code:end_time} die Endzeit gemessen und die Differenz als Antwortzeit berechnet. Der Test wurde zehn mal durchgeführt und es ergab sich hierbei eine mittlere Antwortzeit von 26.66 Sekunden, was deutlich über den gewünschten sechs Sekunden liegt. Besonders Zeitaufwendig sind hierbei die Konvertierung der Audiodaten in Text, die Berechnungen des Sprachmodells bei dem Aufruf von \textit{language\_model.get\_response(text)} als auch die Ausgabe der Antwort über die Lautsprecher, die bei den Tests mit eingeflossen ist und deren Dauer von der ausgewählten Antwort abhängt. Dabei beträgt die Ausführungszeit des Sprachmodells etwas über fünf Sekunden. Als Beispielsatz wurde \glqq{}Mischmaschine. Ich hätte gerne ein Getränk zu 50 Prozent aus Behälter 1 und zu 50 Prozent aus Behälter 2.\grqq{} verwendet. Die Ausführungszeit der Spracherkennung liegt bei etwa 15 Sekunden und macht damit den mit Abstand größten Zeitverlust aus.\\\\
Eine weitere Anforderung war, dass zum Betreiben der Mischmaschine zusammen mit der Sprachsteuerung keine Anbindung zum Internet notwendig sein darf. Diese Anforderung wurde formuliert, damit die Mischmaschine an möglichst vielen Orten betrieben werden kann. Sie wurde in der finalen Umsetzung erreicht, indem alles was für die Sprachsteuerung notwendig ist auf lokaler Hardware ausgeführt wird und auf die Auslagerung von Berechnungen auf Cloud-Services o.ä. verzichtet wurde.\\\\
Lautstärke...\\\\
Entfernung...\\\\
Die Antworten der Mischmaschine sollten humorvoll und kontrollierbar sein und die Kommunikation sollte auf Deutsch stattfinden können. Alle diese Anforderungen wurden im finalen Produkt erreicht. Bei dem gewählten Ansatz für das Sprachmodell werden vordefinierte Antworten je Klasse ausgewählt. Dadurch ist die Grenze bzgl. dem Humor nur durch die eigene Kreativität gesetzt und die Kontrollierbarkeit ist trivialerweise gegeben, da die Antworten eben manuell vorgegeben werden und somit klar ist, was die Mischmaschine in einer bestimmten Situation antworten kann und was nicht. Spracherkennung und -verarbeitung sind auf die deutsche Sprache ausgerichtet.\\\\
Kosten...\\\\
Der Speicherplatz der 32 \ac{GB} SD-Karte, die für dieses Projekt zur Verfügung stand wurde nicht ausgelastet. Ebenso konnte das Programm für die Spracherkennung ohne Probleme mit den verfügbaren 4 \ac{GB} Arbeitsspeicher ausgeführt werden. Deshalb gelten die anfangs festgelegten Ziele bzgl. des Arbeits- und Festplattenspeicherverbrauchs als erfüllt. Tatsächlich beläuft sich der noch Verfügbare Speicher im Wurzelverzeichnis des Dateisystems am Ende des Projekts noch auf 18 \ac{GB}, was einer Auslastung von lediglich 37 Prozent entspricht, obwohl betriebssystemseitige Programme und Dateien ebenfalls mit in diese Statistik eingehen. Während die Quellcodedateien dieses Projekts kaum einen nennenswerten Beitrag zu der Gesamtgröße leisten, verbrauchen die Spracherkennungs- und verarbeitungsmodelle hingegen vergleichsweise viel Speicher. Die Größe des \glqq{}tiny\grqq{}-Modells von \textit{OpenAI Whisper} beläuft sich auf 73.801 Kilobyte (die \glqq{}medium\grqq{}-Variante erreicht bereits eine Größe von ungefähr 1.5 \ac{GB}). Die von der \ac{NLTK}-Bibliothek verwendeten Dateien nehmen 60 Megabyte Speicher ein. Der Arbeitsspeicherverbrauch bei der Ausführung der Sprachsteuerung erreicht Spitzen von fast einem Gigabyte, also ein Viertel des verfügbaren Arbeitsspeichers. Getestet wurde der Abreitsspeicherverbrauch mit den Python-Bibliotheken `os' und `psutil'. Der Aufruf \textit{psutil.Process(os.getpid()).memory\_info().rss / 1024 ** 2} ergibt dann den aktuellen Verbrauch in Mebibytes.\\\\
Zu guter letzt sollte das System leicht an neue Begebenheiten angepasst werden können. Als Beispiel wurde das Hinzukommen eines neuen Behälters angeführt. In diesem Fall müsste auf Seiten des Arduinos lediglich ein zusätzlicher Prozentwert ausgelesen und damit die Pumpe für den neuen Behälter angesteuert werden. Für das Sprachmodell ergeben sich keine Änderungen (bis auf die Vergrößerung des Arrays für das Speichern der Prozentwerte), da hier bereits eine beliebige Anzahl von Behältern und Prozentwerten extrahiert werden können. Alles in allem ist das Hinzukommen eines neuen Behälters also mit moderatem Aufwand zu bewerkstelligen. Weitere Änderungen die in Zukunft auftreten könnten sind das Ändern der Sprache oder das Hinzufügen neuer Antworten oder Klassen. All dies ist ebenfalls mit moderatem Aufwand zu handhaben. Zum Hinzufügen neuer Antworten reicht das Abändern der \textit{patterns.json}-Datei. Für eine neue Klasse müssten zunächst Muster, also Beispieltexte, für diese Klasse geschrieben und dann das Modell neu trainiert werden. Beim Ändern der Sprache kann für die Spracherkennung eines der Modelle von \textit{OpenAI Whisper} verwendet werden. Die tatsächlichen Änderungen am Code würden sich auf eine einzige Zeile beim Aufruf der \textit{recognize\_whisper}-Methode von der \textit{SpeechRecognition}-Bibliothek beschränken. Das Sprachmodell zur Klassifizierung und Extraktion müsste jedoch neu trainiert werden.
\section{Probleme}
Ein Problem ist die lange Reaktions- bzw. Antwortzeit des Systems, die im Schnitt bei 26.66 Sekunden liegt. Beim Testen entpuppte sich dabei die Spracherkennung mit dem Modell von \textit{OpenAI Whisper} als größter Zeitfresser und das obwohl bereits das kleinste Modell \glqq{}tiny\grqq{} verwendet wurde.\\\\
Als ein weiteres Problem kann die unintuitive Formulierung der Sprachbefehle, die vom Benutzer gefordert wird, angesehen werden. Die Beschreibung des gewünschten Mischgetränks durch Nennung der einzelnen Behälter und ihrer Prozentangaben könnte von einigen Benutzern als umständlich erarchtet werden (\glqq{}Ich hätte gerne ein Getränk, das zu 50 Prozent aus Behälter 1 und zu 50 Prozent aus Behälter 2 besteht.\grqq{} usw.). Eine intuitivere Formulierung ist bspw. \glqq{}Mischmaschine, bitte gebe mir Getränk xyz aus.\grqq{}. Dazu müsste es die Möglichkeit geben, vordefinierte Mischungen als Getränke in der Mischmaschine abzuspeichern.\\\\
Hardware nicht richtig eingebaut...\\\\
Hot-Word-Erkennung... 
\section{Mögliche Erweiterungen}
Eine mögliche Erweiterung ist die Verkürzung der Reaktionszeit bei der Spracherkennung. Dies könnte durch die Verwendung einer anderen Spracherkennungs-\ac{API} bzw. eines anderen Modells erreicht werden. Falls keine Bibliothek existiert, die die Anforderungen an die Antwortzeit erfüllt, kann ein eigenes Modell trainiert werden. Dieses könnte so angepasst sein, dass es nur auf eine kleine Teilmenge der deutschen Sprache trainiert ist. Es kommen bei der Anwendung der Sprachsteuerung nämlich nur ein Bruchteil der Worte der deutschen Sprache vor, wie etwa \glqq{}Behälter\grqq{}, \glqq{}Mischmaschine\grqq{}, \glqq{}Getränk\grqq{} oder Zahlen. Dadurch kann das Modell klein und performant gehalten werden. Auch sollte die Spracherkennung insgesamt dadurch verbessert werden, da nicht so viele Worte existieren, zwischen denen unterschieden werden muss.\\\\
Das Speichern vordefinierter Mischungen in Form von Getränken in der Mischmaschine ist eine weitere sinnvolle Ergänzung. Dies kann sinnvollerweise in der bereits existierenden Administrationsansicht der Getränkemischmaschine über das Touch-Display erfolgen. Die Daten über die Getränkekonfigurationen könnten dabei an den Raspberry Pi übertragen werden, der diese persistiert. Das Sprachmodell müsste auf eine Art und Weise angepasst werden, die es ermöglicht, Getränkenamen aus dem Text zu extrahieren. Die Mischungsverhältnisse, die dem Namen zugeordnet sind könnten dann wieder zur Ansteuerung der Pumpen verwendet werden.\\\\
Im Moment dient die Sprachsteuerung lediglich der Bestellung von Getränken. In Zukunft ist es jedoch denkbar den Umfang der verfügbaren Befehle auszuweiten. Als sinnvoll erachtete Befehle sind bspw. die Administration der Mischmaschine über die Sprachsteuerung, das Einleiten des Spülvorgangs, das Umbenennen von Behältern oder das Anlegen von Getränkekonfigurationen.\\\\
Um unnötige Hardware aus der Mischmaschine zu entfernen kann in Betracht gezogen werden den Arduino-Mikrocontroller vollständig durch den Raspberry Pi zu ersetzen und dafür die \ac{GPIO}-Pins des Raspberry zu verwenden, die kurz in Abschnitt \ref{section:raspberry} beschrieben wurden. Die beiden Pins GPIO 14 (TXD) und GPIO 15 (RXD), sowie einer der Ground-Pins können für die serielle Kommunikation mit dem \textit{Nextion}-Display verwendet werden. Fünf weitere Pins für das Steuern der Pumpen (alle \ac{GPIO}s des Raspberry unterstützen Software-Pulsweitenmodulation, auch wenn diese nicht so genau ist wie in Hardware implementierte Pulsweitenmodulation). Ein weiterer Ground-Pin sowie einer der 5V-Pins müssten für die Versorgung des Raspberry mit Strom reserviert werden. Dadurch könnte der Raspberry direkt mit dem Display und den Pumpen kommunizieren und der Übertragungsweg zu dem Mikrocontroller würde entfallen.\\\\
Hardware richtig einbauen...\\\\
Hot-Word-Erkennung...



